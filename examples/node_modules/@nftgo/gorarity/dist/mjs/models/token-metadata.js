import { normalizeAttributeString } from './utils/attribute-utils';
export class StringTrait {
    _name;
    _value;
    constructor(name, value) {
        this._name = normalizeAttributeString(name);
        if (typeof value === 'string') {
            this._value = normalizeAttributeString(value);
        }
        else {
            throw new TypeError(`provide trait value has invalid type: ${typeof value}, must be string.`);
        }
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
    }
    get value() {
        return this._value;
    }
}
export class TokenMetadata {
    _stringTraits = new Map();
    constructor(stringTraits) {
        if (!stringTraits)
            return;
        this._stringTraits = TokenMetadata.normalizeTraits(stringTraits);
    }
    get stringTraits() {
        return this._stringTraits;
    }
    static normalizeTraits(traits) {
        const normalizedTraits = new Map();
        traits.forEach((trait, traitName) => {
            const normalizedTraitName = normalizeAttributeString(traitName);
            if (trait.name !== normalizedTraitName) {
                trait.name = normalizedTraitName;
            }
            normalizedTraits.set(normalizedTraitName, trait);
        });
        return normalizedTraits;
    }
    static fromTokenTraits(tokenTraits) {
        const stringTraits = new Map();
        for (const trait of tokenTraits) {
            if (typeof trait.traitValue === 'string') {
                stringTraits.set(trait.traitType, new StringTrait(trait.traitType, trait.traitValue));
            }
            else {
                throw new TypeError(`provide trait value has invalid type: ${typeof trait.traitValue}, must be string.`);
            }
        }
        return new TokenMetadata(stringTraits);
    }
    toTraits() {
        const result = new Map();
        Array.from(this._stringTraits.values()).forEach((trait) => {
            result.set(trait.name, trait.value);
        });
        return result;
    }
    traitExists(traitName) {
        const normalizedName = normalizeAttributeString(traitName);
        return Boolean(this._stringTraits.get(normalizedName));
    }
    addTrait(trait) {
        this._stringTraits.set(trait.name, trait);
    }
}
