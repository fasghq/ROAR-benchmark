"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collection = void 0;
const token_metadata_1 = require("./token-metadata");
const attribute_utils_1 = require("./utils/attribute-utils");
class Collection {
    constructor(tokens, name = '') {
        this._name = name;
        this._tokens = tokens;
        this._traitsFrequencyCounts = this.deriveNormalizedTraitsFrequencyCounts();
    }
    get name() {
        return this._name;
    }
    get tokens() {
        return this._tokens;
    }
    get tokenTotalSupply() {
        return this._tokens.length;
    }
    get traitsFrequencyCounts() {
        return this._traitsFrequencyCounts;
    }
    tokenStandards() {
        const tokenStandards = new Set();
        this._tokens.forEach((token) => {
            tokenStandards.add(token.tokenStandard);
        });
        return Array.from(tokenStandards.values());
    }
    /**
     * @description Return the number of tokens owning the trait.
     * @param trait
     */
    totalTokensWithTrait(trait) {
        var _a;
        return ((_a = this._traitsFrequencyCounts.get(trait.name)) === null || _a === void 0 ? void 0 : _a.get(trait.value)) || 0;
    }
    extractNullTraits() {
        const result = new Map();
        Array.from(this._traitsFrequencyCounts.entries()).forEach(([traitName, traitValues]) => {
            let totalTraitCount = 0;
            Array.from(traitValues.values()).forEach((traitCount) => (totalTraitCount += traitCount));
            const assetsWithoutTrait = this.tokenTotalSupply - totalTraitCount;
            if (assetsWithoutTrait > 0) {
                result.set(traitName, { trait: new token_metadata_1.StringTrait(traitName, 'Null'), totalTokens: assetsWithoutTrait });
            }
        });
        return result;
    }
    extractCollectionTraits() {
        const result = new Map();
        Array.from(this._traitsFrequencyCounts.entries()).forEach(([traitName, traitValues]) => {
            Array.from(traitValues.entries()).forEach(([traitValue, traitCount]) => {
                const arr = result.get(traitName);
                if (arr) {
                    arr.push({ trait: new token_metadata_1.StringTrait(traitName, traitValue), totalTokens: traitCount });
                    result.set(traitName, arr);
                }
                else {
                    result.set(traitName, new Array({ trait: new token_metadata_1.StringTrait(traitName, traitValue), totalTokens: traitCount }));
                }
            });
        });
        return result;
    }
    /**
     * @description Count the number of occurrence of each trait. Use traitName and traitValue to uniquely identify a trait.
     */
    deriveNormalizedTraitsFrequencyCounts() {
        const traitsFrequencyCounts = new Map();
        for (const token of this._tokens) {
            Array.from(token.metadata.stringTraits.entries()).forEach(([traitName, strTrait]) => {
                const normalizedName = (0, attribute_utils_1.normalizeAttributeString)(traitName);
                const map = traitsFrequencyCounts.get(normalizedName);
                if (map) {
                    const currentCount = map.get(strTrait.value) || 0;
                    map.set(strTrait.value, currentCount + 1);
                    traitsFrequencyCounts.set(normalizedName, map);
                }
                else {
                    traitsFrequencyCounts.set(normalizedName, new Map().set(strTrait.value, 1));
                }
            });
        }
        return traitsFrequencyCounts;
    }
}
exports.Collection = Collection;
