"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TokenMetadata = exports.StringTrait = void 0;
const attribute_utils_1 = require("./utils/attribute-utils");
class StringTrait {
    constructor(name, value) {
        this._name = (0, attribute_utils_1.normalizeAttributeString)(name);
        if (typeof value === 'string') {
            this._value = (0, attribute_utils_1.normalizeAttributeString)(value);
        }
        else {
            throw new TypeError(`provide trait value has invalid type: ${typeof value}, must be string.`);
        }
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
    }
    get value() {
        return this._value;
    }
}
exports.StringTrait = StringTrait;
class TokenMetadata {
    constructor(stringTraits) {
        this._stringTraits = new Map();
        if (!stringTraits)
            return;
        this._stringTraits = TokenMetadata.normalizeTraits(stringTraits);
    }
    get stringTraits() {
        return this._stringTraits;
    }
    static normalizeTraits(traits) {
        const normalizedTraits = new Map();
        traits.forEach((trait, traitName) => {
            const normalizedTraitName = (0, attribute_utils_1.normalizeAttributeString)(traitName);
            if (trait.name !== normalizedTraitName) {
                trait.name = normalizedTraitName;
            }
            normalizedTraits.set(normalizedTraitName, trait);
        });
        return normalizedTraits;
    }
    static fromTokenTraits(tokenTraits) {
        const stringTraits = new Map();
        for (const trait of tokenTraits) {
            if (typeof trait.traitValue === 'string') {
                stringTraits.set(trait.traitType, new StringTrait(trait.traitType, trait.traitValue));
            }
            else {
                throw new TypeError(`provide trait value has invalid type: ${typeof trait.traitValue}, must be string.`);
            }
        }
        return new TokenMetadata(stringTraits);
    }
    toTraits() {
        const result = new Map();
        Array.from(this._stringTraits.values()).forEach((trait) => {
            result.set(trait.name, trait.value);
        });
        return result;
    }
    traitExists(traitName) {
        const normalizedName = (0, attribute_utils_1.normalizeAttributeString)(traitName);
        return Boolean(this._stringTraits.get(normalizedName));
    }
    addTrait(trait) {
        this._stringTraits.set(trait.name, trait);
    }
}
exports.TokenMetadata = TokenMetadata;
